package com.dandan.stats.cleaner;

/**
 *
 * @author dacelent
 */
import redis.clients.jedis.Jedis;
import redis.clients.jedis.Pipeline;
import redis.clients.jedis.ScanParams;
import redis.clients.jedis.ScanResult;

import java.io.FileWriter;
import java.io.IOException;
import java.time.Instant;
import java.util.List;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

public class StatsCleaner1 {

    private static final int BATCHSIZE = 200;
    private static final String YEARMONTHDAY = "20120720";
    private static final int SLICE_SIZE = 40;
    private static final Pattern RE = Pattern.compile("stats/.*/(month|week|day|hour|minute):(?<year>\\d{4})(?<month>\\d{2})(?<day>\\d{2})\\d*$");

    public static void main(String[] args) {
        if (args.length < 2) {
            System.out.println("Usage: java CleanStats <host> <pattern> [resume_at]");
            System.exit(1);
        }

        String host = args[0];
        String matchPattern = args[1];
        String resumeAt = args.length > 2 ? args[2] : null;

        try {
            cleanStats(host, matchPattern, resumeAt);
        } catch (IOException e) {
            System.err.println("Error writing to log file: " + e.getMessage());
        }
    }

    private static void cleanStats(String host, String matchPattern, String resumeAt) throws IOException {
        Jedis jedis = new Jedis(host);
        int dels = 0;
        int count = 0;
        Instant now = Instant.now();

        String logFilename = "REDIS_HL_STATS_" + now.getEpochSecond() + ".log";
        FileWriter out = new FileWriter(logFilename);

        out.write("Logged on " + now + "\n\nRunning on " + host + " with " + matchPattern + 
                  " and batchsize " + BATCHSIZE + " resuming at " + (resumeAt != null ? resumeAt : "0") + "\n\nINFO:\n");

        // Escribir información de Redis en el archivo log
        jedis.info().lines().forEach(line -> {
            try {
                out.write(line + "\n");
            } catch (IOException e) {
                e.printStackTrace();
            }
        });

        out.write("\nOUTPUT:\n");
        out.flush();

        try {
            String cursor = "0";
            do {
                ScanParams scanParams = new ScanParams().match(matchPattern).count(SLICE_SIZE);
                ScanResult<String> scanResult = jedis.scan(cursor, scanParams);
                cursor = scanResult.getCursor();
                List<String> keys = scanResult.getResult();

                if (!keys.isEmpty()) {
                    System.out.print(".");
                    Pipeline pipeline = jedis.pipelined();
                    
                    // Filtrar las claves por fecha
                    keys.removeIf(key -> !shouldDeleteKey(key, YEARMONTHDAY));

                    if (!keys.isEmpty()) {
                        System.out.print("S");
                        List<String> values = jedis.mget(keys.toArray(new String[0]));

                        // Escribir las claves y valores en el archivo log
                        for (int i = 0; i < keys.size(); i++) {
                            out.write(keys.get(i) + " => " + values.get(i) + "\n");
                        }
                        out.flush();

                        System.out.print("M");
                        // Eliminar las claves
                        pipeline.del(keys.toArray(new String[0]));
                        dels += keys.size();
                        System.out.print("D" + keys.size());
                        
                        pipeline.sync();
                        Thread.sleep(10);  // Similar a `sleep 0.01` en Ruby
                    }
                }
            } while (!cursor.equals("0"));
        } catch (InterruptedException e) {
            System.out.println("\n*** INTERRUPTED\n");
            out.write("\n*** INTERRUPTED\n");
        } catch (Exception e) {
            System.out.println("\n*** ERROR: " + e.getMessage());
            out.write("\n*** ERROR: " + e.getMessage() + "\n");
        } finally {
            // Registro final de la operación
            out.write("\nDELS: " + dels + "\n\nFINAL INFO:\n");
            jedis.info().lines().forEach(line -> {
                try {
                    out.write(line + "\n");
                } catch (IOException e) {
                    e.printStackTrace();
                }
            });
            out.flush();
            out.close();
            jedis.close();
        }
    }

    private static boolean shouldDeleteKey(String key, String yearMonthDayThreshold) {
        Matcher matcher = RE.matcher(key);
        if (matcher.matches()) {
            String dateStr = matcher.group("year") + matcher.group("month") + matcher.group("day");
            return Integer.parseInt(dateStr) <= Integer.parseInt(yearMonthDayThreshold);
        }
        return false;
    }
}
